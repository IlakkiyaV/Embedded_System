unsigned int t0count = 0;
char txt[6];
unsigned short state = 0;

// LCD pin configuration
sbit LCD_RS at RD0_bit;
sbit LCD_EN at RD1_bit;
sbit LCD_D4 at RD2_bit;
sbit LCD_D5 at RD3_bit;
sbit LCD_D6 at RD4_bit;
sbit LCD_D7 at RD5_bit;

sbit LCD_RS_Direction at TRISD0_bit;
sbit LCD_EN_Direction at TRISD1_bit;
sbit LCD_D4_Direction at TRISD2_bit;
sbit LCD_D5_Direction at TRISD3_bit;
sbit LCD_D6_Direction at TRISD4_bit;
sbit LCD_D7_Direction at TRISD5_bit;

// Timer0 ISR
void interrupt() {
    if (INTCON.T0IF) {
        INTCON.T0IF = 0;
        TMR0 = 6;        // Preload for ~1.28 ms delay
        t0count++;       // Count each overflow
    }
}

void main() {
    TRISB = 0x00;     // PORTB = Output for LED
    TRISD = 0x00;     // PORTD = Output for LCD
    PORTB = 0x00;

    Lcd_Init();                 // Initialize LCD
    Lcd_Cmd(_LCD_CLEAR);
    Lcd_Cmd(_LCD_CURSOR_OFF);
    Lcd_Out(1, 1, "TMR0 + LED Blink");

    OPTION_REG = 0x07;  // Prescaler = 256, internal clk
    TMR0 = 6;           // Start from 6
    INTCON.T0IE = 1;    // Enable TMR0 interrupt
    INTCON.GIE = 1;     // Enable global interrupts

    while (1) {
        // Display Timer0 overflow count on LCD
        WordToStr(t0count, txt);
        Lcd_Out(2, 1, "Count:");
        Lcd_Out(2, 8, txt);

        // LED blink every 1 second
        switch (state) {
            case 0:
                if (t0count >= 781) { // 781 × 1.28ms ˜ 1s
                    t0count = 0;
                    state = 1;
                    PORTB = 0xFF;     // LED ON
                }
                break;

            case 1:
                if (t0count >= 781) {
                    t0count = 0;
                    state = 0;
                    PORTB = 0x00;     // LED OFF
                }
                break;
        }

        Delay_ms(100); // Update LCD every 100ms
    }
}
